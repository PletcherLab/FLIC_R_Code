---
title: "FLIC: Data Analysis Part 1: Introduction and DFM Data"
author: "Scott Pletcher and the Pletcher Lab"
date: "9/2/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

This document begins a series of markdown files that contain working examples that will hopefully make it easier to understand how we analyze the signal data from FLIC DFMs. We have written many R functions that we find useful for analyzing simple feeding experiments that involve one feeding well per chamber as well as choice experiments that involve two feeding wells per chamber.  These markdown files currently serve as the documentation for all functions.  The source code is (semi) commented and available from GitHub (https://github.com/PletcherLab/FLIC_R_Code). The example data files are available in the repository as an archived (i.e., zipped) file. You may also contact [Scott](mailto:spletch@umich.edu) if you have specific questions or would like to interrogate your data in a specific way that doesn't appear to be supported in the code. 

As with all FLIC R code, this is a work in progress. If you decide to extend this code and wish to share it with the community, please contact [Scott](mailto:spletch@umich.edu).

## Getting Started
1. Download and install the latest version of [R](https://cran.r-project.org/) or [Microsoft Open R](https://mran.microsoft.com/open) for your operating system.

2. Download R studio (https://www.rstudio.com/) and install it. 

3. Create a new folder on your hard drive to serve as the project directory.  

4. Copy all of  DFM data files (e.g., "DFM_1.csv") to that folder.  

5. Clone the Github Respository or download the files as a zip file. Unzip or copy the .R files and/or the FLICFUNCTIONS file to the project directory. 

6. Start R studio. Choose File|New Project and click "Existing Directory."  Point to your project folder. R Studio will set the default directly to your project folder.  You are ready to start analyzing your feeding interaction data!

7. You will need to ensure that you have the following R packages installed: *ggplot2*, *stats*, *reshape2*, and *gridExtra*. If you are new to R, you can find lots of information about packages and installing them in RStudio with a simple web search (e.g., [here](https://www.datacamp.com/community/tutorials/r-packages-guide) and [here](http://web.cs.ucla.edu/~gulzar/rstudio/))

There are two options for providing access to the FLIC functions.  Attach the R object to the search path (assuming the file in is the working directory), preferably in a search position higher than 1 (note the *pos=2* argument to *attach()*) so that the function definitions don't clutter your working environment.

```{r}
library(ggplot2)
library(stats)
library(gridExtra)
library(reshape2)
attach("FLICFunctions",pos=2)
```

Alternatively, you may copy all of the R files to the project directory and source those that are required.
```{r}
source("DFM.R")
source("CommonChamber.R")
source("ChoiceFunctions.R")
source("MiscFunctions.R")
```

## Loading DFM Data 

The FLIC analysis code is loosely based on an object oriented concept,although R itself is not OOP friendly.Some functions will therefore include "Class" in their name. These create "objects" that will contain the data or other relevant information. To signify the type of data that we have and the parameters that will be used to identify food interactions, we first need to create a parameters object.  For this example, we would like a set of default parameters for a choice chamber in which two feeding wells are presented in each behavioral chamber as a food choice.

```{r}
p.choice<-ParametersClass.TwoWell()
```

Examine the components of this object.

```{r}
attributes(p.choice)
```

and their respective default values.

```{r echo=FALSE}
p.choice
```

Parameter               |   Definition
----------------------- | ---------------------------------------------------------------------------------------
Baseline.Window.Minutes | The window size (in minutes) used to normalize the (i.e., non-feeding) signal to zero.
Feeding.Threshold       | The normalized signal above which a feeding interaction is indicated to have occured.
Feeding.Minimum         | The minimum normalized signal indicating a feeding interaction (must link to a signal above threshold). 
Tasting.Minimum         | A normalized signal is considered to be generated by a fly if it is not a feeding interaction  
Tasting.Maximum         | and lies between Tasting.Minimum and Tasting.Maximum. 
Feeding.Minevents       | The number of consecutive feeding signals required to constitute a feeding event.
Tasting.Minevents       | The number of consecutive tasting signals required to constitute a tasting event.
Samples.Per.Second      | The sample frequency of signal capture (normally 5 for the standard MCU). Do not modify. 
Chamber.Size            | The number of feeding wells in a behavioral chamber. Will be two for a choice analysis.  Do not modify. 
Chamber.Sets            | Encoding of chamber numerical IDs to their position on the physical DFM.  Do not modify.
PI.Multiplier           | Used to indicate the orientation of food choices on each DFM. Can be -1 or 1. (e.g., 1 indicates left well is WellA).

Note that the feeding- and tasting-related parameters are critical for determining all feeding interactions. We have set the default values to those we commonly use in the Pletcher lab, but you may change them using the SetParameter  function, which takes the current parameter object as its first argument, followed by one or more parameters to set and their new values. Don't forget to reassign the new object. To avoid biasing your tasting data, make sure that Tasting.Maximum <= Feeding.Minimum. 

```{r}
p.choice<-SetParameter(p.choice,Feeding.Threshold=30)
p.choice<-SetParameter(p.choice,Feeding.Minimum=20)
p.choice<-SetParameter(p.choice,Tasting.Interval=c(10,20)) # Tasting.Interval defines minimum and maximum. 
```

```{r echo=FALSE}
p.choice
```

For now we will accept the default values.
```{r}
p.choice<-ParametersClass.TwoWell()
```


If you are executing single well experiments, you would create the relevant parameter object:
```{r}
p.single<-ParametersClass.SingleWell()
```

To load DFM data, you must create DFM classes for each. The *DFMClass()* function loads data from the appropriate .csv file, does a significant number of calculations, creates a dfm object in the working environment (e.g., DFM3, DFM6, etc.), and returns the DFM object. There is no explicit need to assign the returned object, because the background objected is created, but it can often be useful. If this variable is not needed, you should remove it afterward. When loading single DFMs it is best to assign the result regardless, to avoid a lengthy output. In the following code, we assign the results to a dummy variable (*dfm*) to suppress the output to the console. 

The *DFMClass()* function takes the DFM ID as the first argument and a parameters object as the second argument.The associated .cvs files must be in the working/project directory. For the examples presented here, we will use data from two experiments.  An 18-hour single well feeding experiment in DFMs 1-4, and a 6 hour choice experiment in DFMs 11-17. To load data from a few of these DFMs, 
```{r}
dfm.single<-DFMClass(3,p.single)
dfm.choice<-DFMClass(11,p.choice)
dfm12<-DFMClass(12,p.choice)
rm(dfm12) #Note that this does not remove the background object, DFM3.
```
In this case we passed the same parameters object to both DFM11 and DFM12, meaning the same thresholds will be applied in all cases (after baseline normalization for each DFM). Note also that both PI.Multipliers are the same, implying the food on the left is WellA on each DFM (see the two choice documentation for details).

FLIC data can be quite large and you may find that you do not need to analyze data from the entire experiment.  You can limit the range of data that is loaded by specifying a range parameter (in minutes). For example, to load the first two hours of data from one of the DFM in the single-well experiment

```{r}
dfm.focussed<-DFMClass(2,p.single,range=c(0,120))
rm(dfm.focussed) #Note that this does not remove the background object, DFM2.
```

If you have experiments that run longer than one day, the MCU will save a file every 24 hours, creating multiple files for each DFM, such as DFM_2_1.csv, DFM2_2.csv.  To link several files into one DFM object, there is a special DFMClass function:  
```{r, eval=FALSE}
tmp<-DFMClass.LinkFiles(2,p)
rm(tmp)
```
Please consult the advanced user documentation  for details.  Do not use this function for loading experiments that are shorter than 24hours.

## Feeding and Tasting Interactions
The DFMClass functions perform the following actions for each DFM:

1. Load the raw data from the relevant .csv file.

2. Use the date and time information in the first three columns to calculate a start time for the experiment and an elapsed time (in minutes) from that start time for each observation.

3. Calculate a signal baseline for each observation and normalize it by creating 'baselined data.' The signal baseline is calculated by applying a running median with a windows size in minutes defined in the parameter *Baseline.Window.Minutes*. The default value is 3min, providing a window of 900 signals The assumption here is that feeding interactions in any 3min period will be sufficiently rare (i.e., less than 50%) such that the median is the signal value representing no feeding. This type of normalization accounts for signal variation among DFMs and corrects for artifacts in each well that might be caused by things such as overfilling the food. A 'baselined signal' is then calculated and saved by subtracting the baseline from each observation. Baselined signals should be near zero (given some random fluctuation) in the absence of food interactions.

4. Apply the feeding thresholds defined in the relevant parameters object across the normalized (i.e., baselined) signal values in each well to identify interactions that are classified as feeding behaviors. Interactions are classified as feeding interactions (called 'licks' throughout) if they satisfy the following conditions: (*i*) at least one signal exceeds the *Feeding.Threshold* parameter or if a signal exceeds the *Feeding.Minimum* parameter and is linked to at least one signal that exceeds *Feeding.Threshold*. In this way a candidate feeding *Event* (i.e., a contiguous series of licks) is identified to include at least one signal over *Feeding.Threshold* and all contiguous signals that exceed *Feeding.Minimum*, and (*ii*) a candidate feeding event is kept only if the number of continguous licks exceeds the *Feeding.Minevents* parameter. Figure 1 illustrates how feeding licks and events are defined.

```{r, echo=FALSE, fig.cap="Figure 1. Thresholding Concept: PLACE HOLDER, THIS NEEDS TO BE UPDATED", out.width = '30%'}
knitr::include_graphics("Thresholds.png")
```

5. For two-choice experiments, the PI multiplier is used to adjust the link the "WellA" and "WellB" values that are presented  in data output and figures the right or left side of the DFM.  If a DFm is defined with a PI.Multiplier=1 in the parameters object, then the left well is considered WellA.  If the PI.Multiplier is -1, then the right well in the chamber is considered WellA.  In this way, a good experimental design can swap food treatments in different DFM while maintaining an appropriate PI to the different foods. A positive PI indicates preference for Well A.

5. Tasting interactions are then defined as all normalized signals that fall between *Tasting.Minimum* and *Tasting.Maximum* that were not already defined as feeding interaction through the procedure described above.

6. If the associated parameters object defines the DFM as one involving choice (i.e., two wells per chamber) then a PI is calculated for each observation (only for feeding interactions), which is either -1, 1, or 0, based on whether a 'lick' was defined for WellA or WellB or neither, respectively (see also point #5 above).

7. The durations (in seconds) of each feeding/tasting event and the time interval between each feeding/tasting event are calculated.

All of these components are saved and make up the DFM object. You can explore these components on your own if you wish, but they  are used automatically in all of the analysis functions. Please contact [Scott](mailto:spletch@umich.edu) if you would like additional details. 

You may force a change in a specific parameter by replacing the parameters object in a DFM with a new one that has the relevant settings. For example, to restore default parameters to our DFM, do the following. To change DFM1 from a single-well DFM to one involving choice we could work with the background object.

```{r}
DFM3<-ChangeParameterObject(DFM3,p.choice)
```

You can also do this by calling the *DFMClass()*. 

```{r}
tmp<-DFMClass(3,p.single)
rm(tmp)
```

There are many components of a DFM object.

```{r}
attributes(dfm.single)
```

**NOTE:** To avoid the need to recalculate all of the DFM components each time a parameter is changed, the software will first determine whether there is a DFM object saved in the environment (e.g., DFM1 object). If so, it will only perform the above calculates that were invalidated by the parameter change.  It will NOT automatically reload the data.  To ensure that the data are reloaded from the .cvs file, you will either need to manually delete the relevant background DFM object or use the CleanDFM() function, which will delete all background DFM objects.

```{r, eval=FALSE}
rm(DFM3)
CleanDFM()
```
If there are apparent lapses in data collection that amount to more than 1 sec (DFMs collect data at roughly 500Hz and report average signals every 200ms), a warning will be printed.  A closer examination of the problem can be had by using the *FindDataBreaks()* function. Data lapses can happen if the communication signals are noisy, for example when the DFMs are placed in an incubator. They are normally not a problem unless they reach several seconds to one minute. Large data breaks will be interpreted as periods of no feeding, so they need to be avoided. Most often they can not be corrected because they arise from a failure during data collection. Normally, they should not happen. Contact [Scott](mailto:spletch@umich.edu) if you receive this warning often.

```{r}
FindDataBreaks(DFM3)
```

## Interrogating the Data
You can output the first and last observation, which is often useful to ensure that the duration of the experiment is as expected. The *Minutes* and *Seconds* columns provide the elapsed time of the experiment.
```{r}
FirstSampleData(dfm.single)
LastSampleData(dfm.single)
```

You can also extract the raw and baselined data to an R object.

```{r}
data.raw<-RawData(dfm.single)
data.normalized<-BaselineData(dfm.single)
head(data.raw)
head(data.normalized)
```

Many functions, including the *RawData* and *BaselinedData* functions, accept an optional range parameter that is used to return or focus on only a subset of the experiment.  The units for the range parameters are minutes.  To return the raw data for a period from 10-20min after the experiment started

```{r}
data.raw<-RawData(dfm.single,range=c(10,20))
head(data.raw)
```

You can examine the function definition by typing its name, without parentheses, at the R prompt or by examining the source code.

```{r}
RawData
```

Simple plots and outputs displaying various aspects of the data are available.  Higher quality plots and more complex outputs that take into account experiments treatments, as well as details about additional DFM components (e.g., Durations and Intervals) are described in other markdown files. Sometimes the plots will be different for single-well and choice experiments.  It is important to note that regardless of experiment type, Wells are numbered from left to right and top to bottom.  So, Well 5 is always the left well in Row 3, regardless of the value of the PI.Multiplier. However, WellA for Chamber 3 will be the left well in Row three (i.e., Well 5) if the PI.Multiplier = 1 and the right well in Row 3 (i.e., Well 6) if the PI.Multiplier = -1.

To display a plot of the raw or baselined for a dfm. These functions plot MANY points and can be quite slow to produce and display. They both take a range parameter to focus on a particular period in time. Note how the slightly higher baseline in Well 8 is corrected in the normalized data. Dramatic and peristant changes in the rawdata plots are cause for concern.

```{r, fig.height=11}
RawDataPlot.DFM(dfm.single,OutputPNGFile = TRUE) # This will save a .png file but will not show one.
BaselinedDataPlot.DFM(dfm.single,range=c(0,100),OutputPNGFile = FALSE) #This will show the plot and not save it to a file.
```

You can overlay the current feeding parameters (*Feeding.Threshold* and *Feeding.Minimum*) on the baselinedata plots as follows (this is currently not available for tasting parameters).

```{r, fig.height=11}
BaselinedDataPlot.DFM(dfm.choice, range=c(0,100), IncludeThresholds=TRUE,OutputPNGFile = FALSE)
```

A simple summary of the licks from one DFM can be obtained with the feeding summary.  The format of this object depends on the type of experiment (single-well or choice). This function applies to a single DFM, as noted by the last part of the function name.

```{r}
# Summarize the first two hours, and don't transform.
summary.onewell<-Feeding.Summary.DFM(dfm.single,range=c(0,120),TransformLicks=FALSE) 
summary.choice<-Feeding.Summary.DFM(dfm.choice)
head(summary.onewell)
head(summary.choice)
```
For single-well experiments, the results are presented as a series of columns in a data frame, the definition of which are as follows:

Column                  |   Definition
----------------------- | ---------------------------------------------------------------------------------------
DFM                     | The DFM ID number.
Chamber                 | The chamber number (1-12) numbered as in the parameter vector.
Licks                   | The number of feeding licks in the defined range (the entire experiment if not specified). 
Events                  | The number of events (groups of contiguous licks) in the defined range. 
MeanDuration            | The mean duration (in seconds) of feeding events.
MedDuration             | The median duration (in seconds) of feeding events.
MeanTimeBtw             | The mean time (in seconds) between feeding events.
MedTimeBtw              | The median time (in seconds) between feeding events.
MeanInt                 | The mean (normalized) signal intensity across all licks.
MedianInt               | The median (normalized) signal intensity across all licks.
StartMin                | The start of the range (in minutes) examined (0 =  start of experiment).
EndMin                  | The end of the range (in minutes) examined (0 =  end of experiment).


For two-well/choice experiments, the results are presented as a series of columns in a data frame, the definition of which are as follows:

Column                  |   Definition
----------------------- | ---------------------------------------------------------------------------------------
DFM                     | The DFM ID number.
Chamber                 | The chamber number (1-6) numbered from top to bottom as in the parameter vector.
PI (choice only)        | The PI calcualted from licks over the defined range. A positive PI indicates preference for WellA.
Event PI                | The PI calcualted from events over the defined range.
LicksA                  | The number of feeding licks in WellA (left well if PI.Multiplier = 1, right well otherwise) in the defined range.  
LicksB                  | The number of feeding licks in WellB (right well if PI.Multiplier = 1, left well otherwise) in the defined range.
EventsA                 | The number of events (groups of contiguous licks) in WellA in the defined range. 
EventsB                 | The number of events (groups of contiguous licks) in WellB in the defined range. 
MeanDurationA           | The mean duration (in seconds) of feeding events in Well A.
MedDurationA            | The median duration (in seconds) of feeding events in Well A.
MeanDurationB           | The mean duration (in seconds) of feeding events in Well B.
MedDurationB            | The median duration (in seconds) of feeding events in Well B.
MeanTimeBtwA            | The number of feeding wells in a behavioral chamber. Will be two for a choice analysis.
MedTimeBtwA             | The mean time (in seconds) between feeding events in Well A.
MeanTimeBtwB            | Encoding of chamber numerical IDs to their position on the physical DFM.  Do not modify.
MedTimeBtwB             | The mean time (in seconds) between feeding events in Well B.
MeanIntA                | The mean (normalized) signal intensity across all licks in Well A.
MedianA                 | The median (normalized) signal intensity across all licks in Well A.
MeanIntB                | The mean (normalized) signal intensity across all licks in Well B.
MedianIntB              | The median (normalized) signal intensity across all licks in Well B.
StartMin                | The start of the range (in minutes) examined (0 =  start of experiment).
EndMin                  | The end of the range (in minutes) examined (0 =  end of experiment).


We have found that the number of licks is not normally distributed and that a transformation to the 0.25 power is appropriate.  *Feeding.Summary.DFM()* (and most other functions that output licks) has an option to transform the licks data in this way.  Because it is necessary for subsequent statistical analyses (e.g., ANOVA, t-test, etc.), the default behavior is to transform (i.e., *TransformLicks=TRUE* is set in the function definition). Specifying *TransformLicks=FALSE* in the function calls will disable the transformation.  As always, details can be obtained from the function body and defintion.

The *Feeding.Summary.DFM()* function summarizes a range of metrics over the entire range specified.  If you would like to parse the range into non-overlapping bins and to evaluate the feeding interactions in each bin, there is *BinnedFeeding.Summary.DFM()*, which takes one additional parameter that specifies the size of each bin, in minutes.

```{r}
# Summarize the first two hours, and don't transform.
binsummary.onewell<-BinnedFeeding.Summary.DFM(dfm.single,binsize.min=10,range=c(0,120),TransformLicks=FALSE) 
binsummary.choice<-BinnedFeeding.Summary.DFM(dfm.choice,binsize.min = 30)
head(binsummary.onewell)
head(binsummary.choice)
```

For single-well experiments, the results are as follows:

Column                  |   Definition
----------------------- | ---------------------------------------------------------------------------------------
Interval                | The defined limits of the interval (in minutes).
Min                     | The midpoint of the interval (in minutes).
Licks                   | The number of feeding licks in the defined range (the entire experiment if not specified). 
Events                  | The number of events (groups of contiguous licks) in the defined range. 
DFM                     | The DFM ID number.
Chamber                 | The chamber number (1-12) numbered as in the parameter vector.
StartMin                | The start of the range (in minutes) examined (0 =  start of experiment).
EndMin                  | The end of the range (in minutes) examined (0 =  end of experiment).


For choice experiments, the results are similar:

Column                  |   Definition
----------------------- | ---------------------------------------------------------------------------------------
Interval                | The defined limits of the interval (in minutes).
Min                     | The midpoint of the interval (in minutes).
LicksA                  | The number of feeding licks in WellA over the defined range (the entire experiment if not specified). 
LicksB                  | The number of feeding licks in WellA over the defined range (the entire experiment if not specified).  
EventsA                 | The number of events in WellA (groups of contiguous licks) in the defined range.
EventsB                 | The number of events in WellB (groups of contiguous licks) in the defined range. 
DFM                     | The DFM ID number.
Chamber                 | The chamber number (1-6) numbered as in the parameter vector.
StartMin                | The start of the range (in minutes) examined (0 =  start of experiment).
EndMin                  | The end of the range (in minutes) examined (0 =  end of experiment).


Two simple plotting functions help visualize the data for individual DFMS. The first is *CumulativeLicksPlots.DFM(dfm,SinglePlot=FALSE,TransformLicks=TRUE)*, which presents the accumulation of licks over time.  If *SinglePlot=FALSE* (the default behavior), the format of the plot depends on the type of DFM, noting that for choice-chambers, the plot is faceted on WellA and WellB, which are adjusted for PI.Multiplier, and not on the physical location of the wells. However, the color of the lines, which is determined by Well Number and shown in the legend, remains determined by physical location. If *SinglePlot=TRUE* then all lines for both types of DFM represent Well Number and therefore physical location.

```{r, fig.height=11, echo=FALSE}
CumulativeLicksPlots.DFM(dfm.single)
CumulativeLicksPlots.DFM(dfm.choice)
```

```{r}
CumulativeLicksPlots.DFM(dfm.single,SinglePlot=TRUE) # If you would rather have them all on one plot
```

A similar function helps visualize binned data from individual DFMs. *BinnedLicksPlot.DFM()* shows a separate line of binned lick data (transformed by default) for each well of single-well chambers or a stacked bar chart showing the WellA or WellB licks (determined by PI.Multiplier) in each of the six chambers.

```{r, fig.height=11}
BinnedLicksPlot.DFM(dfm.single,binsize.min=20)
```

```{r, fig.height=8}
BinnedLicksPlot.DFM(dfm.choice,binsize.min=10)
```

While transforming the licks is best for quantitative analysis, for the purposes of quality checks on the binned data, it is often best to disable this feature.

```{r, fig.height=11}
BinnedLicksPlot.DFM(dfm.single,binsize.min=20,TransformLicks=FALSE)
```

## Other General Functions

You can obtain information about feeding intervals and durations for each DFM by

```{r}
IandD<-GetIntervalData.DFM(dfm.single)
head(IandD)
```

Column                  |   Definition
----------------------- | ---------------------------------------------------------------------------------------
DFM                     | The DFM ID number.
Well                    | The Well ID number (1-12; for both single and two well chambers).
Minutes                 | The elapsed minutes at which the feeding event began.
IntervalSec             | The duration (in seconds) of the feeding event.
*...Remaining...*       | The individual values of the parameters object used for the DFM calculations.  

You can save the baselined data to a text file for plotting in another program. It will create a .csv file with a reasonable name (e.g., BaselinedData_DFM3.csv for DFM3).

```{r}
OutputBaselinedData.DFM(DFM11)
OutputBaselinedData.DFM(dfm.choice, range=c(0,100)) # Remember DFM11 and dfm.choice point to the same object.
```


## Function Definition Reference
Listed below are the functions used in this document along with their argument list showing optional parameters and their default values.  You should know what each of these functions does and what each argument represents before moving on to the remaining documentation. It is important that these functions, and the larger set of R Code for the FLIC, are not treated as a black box. In our experience the FLIC system provides remarkable insights, but the data sets are large and complex and must be managed carefully to ensure that mistakes are avoided.

```{r, eval=FALSE}
ParametersClass.SingleWell() 

ParametersClass.TwoWell() 

DFMClass(id,parameters,range=c(0,0)) 

DFMClass.LinkFiles(id,parameters,range=c(0,0)) 

FindDataBreaks(dfm,multiplier=4,returnvals=TRUE)

ChangeParameterObject(dfm,newP)

FirstSampleData(dfm)

LastSampleData(dfm)

CleanDFM()

Feeding.Summary.DFM(dfm,range=c(0,0),TransformLicks=TRUE)

BinnedFeeding.Summary.DFM(dfm,binsize.min=30,range=c(0,0),TransformLicks=TRUE)

OutputBaselinedData.DFM(dfm, range=c(0,0))

GetIntervalData.DFM(dfm,range)

RawDataPlot.DFM(dfm,range=c(0,0),OutputPNGFile=FALSE)

BaselinedDataPlot.DFM(dfm,range=c(0,0),OutputPNGFile=FALSE, IncludeThresholds=FALSE)

BinnedLicksPlot.DFM(dfm,binsize.min=30,range=c(0,0),TransformLicks=TRUE)
```